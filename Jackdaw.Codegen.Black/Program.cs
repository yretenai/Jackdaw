using System.Text;
using System.Text.Json;
using Jackdaw.Structs.Trinity.Schema;
using Serilog;

namespace Jackdaw.Codegen.Black;

internal class Program {
	private const string ARRAY_REF = "BlueInterfaceIID<struct IList>";
	private const string DICT_REF = "BlueInterfaceIID<struct IBlueDict>";
	private const string STRUCT_LIST_REF = "BlueInterfaceIID<struct IBlueStructureList>";
	private static readonly string[] IGNORE = ["IWeakObject", "IRoot", "_ClassDef", "object"];

	// ReSharper disable once UnusedMember.Local
	private static string FormatComment(string comment, string indent) {
		if (string.IsNullOrEmpty(comment)) {
			return string.Empty;
		}

		var lines = comment.Split('\n');
		var builder = new StringBuilder();
		builder.Append(indent);
		builder.AppendLine("/// <summary>");
		foreach (var line in lines) {
			builder.Append(indent);
			builder.Append("/// ");
			builder.AppendLine(line);
		}

		builder.Append(indent);
		builder.Append("/// </summary>");

		return builder.ToString();
	}

	private static string FixName(string fieldName) {
		var parts = fieldName.Split(' ', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
		var str = new StringBuilder();

		foreach (var part in parts) {
			str.Append(char.ToUpper(part[0]));
			str.Append(part[1..]);
		}

		return str.ToString();
	}

	private static void Main(string[] args) {
		if (args.Length < 2) {
			Console.WriteLine("Usage: Jackdaw.Codegen.Black <path/to/types.json> <path/to/output>");
			return;
		}

		Log.Logger = new LoggerConfiguration().MinimumLevel.Verbose().WriteTo.Console().CreateLogger();

		var types = JsonSerializer.Deserialize<BlackSchemaRoot>(File.ReadAllText(args[0]))!;
		var output = args[1];

		var hasTypes = types.Types.Values.Where(x => x.Address != 0).Select(x => types.CLSIDs[x.Address].Name).ToHashSet();
		var hasTypesReal = types.Types.Values.Where(x => x.Address != 0 && x.Properties.Count > 0).Select(x => types.CLSIDs[x.Address].Name).ToHashSet();
		var buildInterfaces = new HashSet<string>();
		foreach (var type in types.Types.Values) {
			type.Description = type.Description.Trim();
			if (type.Address is 0) {
				continue;
			}

			var group = "class";
			var name = types.CLSIDs[type.Address].Name;
			if (IGNORE.Contains(name)) {
				continue;
			}

			if (type.Properties.Count == 0 && type.Inherit == 0 && !type.Interfaces.Select(x => types.IIDs[x]).Where(x => !IGNORE.Contains(x) && x != name).Any(x => hasTypesReal.Contains(x))) {
				group = "interface";
			}

			var interfaceList = type.Interfaces.Select(x => types.IIDs[x]).Where(x => !IGNORE.Contains(x) && x != name).OrderBy(x => !hasTypes.Contains(x)).ToList();
			buildInterfaces.UnionWith(interfaceList.Where(x => !hasTypes.Contains(x)));
			if (types.CLSIDs.TryGetValue(type.Inherit, out var inherit)) {
				interfaceList.Insert(0, inherit.Name);
			} else if (types.Types.TryGetValue(type.Inherit, out var inheritType)) {
				interfaceList.Insert(0, types.CLSIDs[inheritType.Address].Name);
			}

			var interfaceListString = interfaceList.Count == 0 ? "" : $": {string.Join(", ", interfaceList.Distinct())} ";
			Log.Information("Generating {Type} {InterfaceList}", name, interfaceListString);

			using var writer = new StreamWriter(Path.Combine(output, $"{name}.cs"));
			writer.WriteLine("/// <auto-generated/>\n#nullable enable\n\nnamespace Jackdaw.Structs.Trinity.Generated;\n");
			// if (!string.IsNullOrWhiteSpace(type.Description)) {
			//     writer.WriteLine(FormatComment(type.Description, string.Empty));
			// }
			writer.Write($"public {group} {name} {interfaceListString}{{");

			if (type.Properties.Count == 0) {
				writer.WriteLine(" }");
				continue;
			}

			writer.WriteLine();

			foreach (var field in type.Properties.OrderBy(x => string.IsNullOrEmpty(x.Description)).DistinctBy(x => x.Name)) {
				field.Description = field.Description.Trim();

				var fieldName = FixName(field.Name);

				var iidType = "object";
				if (ulong.TryParse(field.IID, out var iid) && types.IIDs.TryGetValue(iid, out var cachedIidType)) {
					iidType = cachedIidType;
				}

				var attribute = string.Empty;
				var fieldType = "object";
				// ReSharper disable once SwitchStatementMissingSomeEnumCasesNoDefault
				switch (field.Type) {
					case Structs.Trinity.Schema.BlackSchemaPropertyType.Int:
						fieldType = "int";
						break;
					case Structs.Trinity.Schema.BlackSchemaPropertyType.Single:
						fieldType = "float";
						break;
					case Structs.Trinity.Schema.BlackSchemaPropertyType.Double:
						fieldType = "double";
						break;
					case Structs.Trinity.Schema.BlackSchemaPropertyType.Boolean:
						fieldType = "bool";
						break;
					case Structs.Trinity.Schema.BlackSchemaPropertyType.PureRef:
						switch (field.IID) {
							case ARRAY_REF:
								fieldType = "object[]?";
								break;
							case DICT_REF:
								fieldType = "object?";
								attribute = "[BlackExperimental] ";
								break;
							case STRUCT_LIST_REF:
								fieldType = "byte[][]?";
								attribute = "[BlackPureRef] ";
								break;
							default: {
								fieldType = iidType + "?";
								attribute = "[BlackPureRef] ";
								if (!hasTypes.Contains(iidType)) {
									buildInterfaces.Add(iidType);
								}

								break;
							}
						}

						break;
					case Structs.Trinity.Schema.BlackSchemaPropertyType.Object:
						fieldType = iidType + "?";
						if (!hasTypes.Contains(iidType)) {
							buildInterfaces.Add(iidType);
						}

						break;
					case Structs.Trinity.Schema.BlackSchemaPropertyType.Long:
						fieldType = "long";
						break;
					case Structs.Trinity.Schema.BlackSchemaPropertyType.PythonObject:
					case Structs.Trinity.Schema.BlackSchemaPropertyType.PythonWeakref:
					case Structs.Trinity.Schema.BlackSchemaPropertyType.PythonFunction:
						fieldType = "object?";
						attribute = "[BlackExperimental] ";
						break;
					case Structs.Trinity.Schema.BlackSchemaPropertyType.FloatArray:
						fieldType = "float[]?";
						attribute = $"[BlackArraySize({field.Size / 4})] ";
						break;
					case Structs.Trinity.Schema.BlackSchemaPropertyType.String:
					case Structs.Trinity.Schema.BlackSchemaPropertyType.UTFString:
						fieldType = "string?";
						break;
					case Structs.Trinity.Schema.BlackSchemaPropertyType.WString:
						fieldType = "string?";
						attribute = "[BlackUseNamePool] ";
						break;
					case Structs.Trinity.Schema.BlackSchemaPropertyType.Buffer:
						fieldType = "int[]?";
						attribute = "[BlackPureRef(4)] ";
						break;
					case Structs.Trinity.Schema.BlackSchemaPropertyType.Byte:
						fieldType = "byte";
						break;
					case Structs.Trinity.Schema.BlackSchemaPropertyType.Short:
						fieldType = "short";
						break;
				}

				// if (!string.IsNullOrWhiteSpace(field.Description)) {
				//     writer.WriteLine(FormatComment(field.Description, "    "));
				// }

				writer.WriteLine($"    {attribute}public {fieldType} {fieldName} {{ get; set; }}");
			}

			writer.WriteLine("}");
		}

		foreach (var buildInterface in buildInterfaces) {
			if (IGNORE.Contains(buildInterface)) {
				continue;
			}

			File.WriteAllText(Path.Combine(output, $"{buildInterface}.cs"), $"/// <auto-generated/>\nnamespace Jackdaw.Structs.Trinity.Generated;\n\npublic interface {buildInterface} {{ }}\n");
		}
	}

	internal enum BlackSchemaPropertyType {
		None,
		Int = 1,
		Single = 2,
		Double = 3,
		Boolean = 4,
		PureRef = 5,
		Object = 6,
		Unused7 = 7,
		Unused8 = 8,
		Long = 9,
		Unused10 = 10,
		PythonWeakref = 11,
		Unused12 = 12,
		Unused13 = 13,
		Unused14 = 14,
		FloatArray = 15,
		Unused16 = 16,
		Unused17 = 17,
		Unused18 = 18,
		Unused19 = 19,
		Unused20 = 20,
		PythonObject = 21,
		Unused22 = 22,
		String = 23,
		WString = 24,
		Buffer = 25,
		Unused26 = 26,
		Unused27 = 27,
		Unused28 = 28,
		Unused29 = 29,
		Unused30 = 30,
		Byte = 31,
		Short = 32,
		PythonFunction = 33,
		InlineString = 34,
	}
}
